LABORATORY WORK 3

Variant 10

Тема: Сайт знайомств 
Сутності: Анкета, Ключові слова, Відкрита інформація, Закрита інформація, Запрошення 
Актори: Користувач 
Сценарії використання: 
Користувач: 
- Редагування власної анкети, 
- Перегляд анкет, 
- Пошук анкет за ключовими словами,
- Відправка Запрошення, 
- Перегляд Закритої Інформації іншого користувача при
отриманні від нього Запрошення чи підтвердження власного запрошення

</br>

1. :warning: **Опишіть механізм наслідування в JavaScript.**
Механізм наслідування в JavaScript заснований на прототипах. В JavaScript кожен об'єкт має внутрішній посилання на інший об'єкт, який називається прототипом. При спробі отримати властивість чи метод об'єкту, якого немає в самому об'єкті, JavaScript автоматично шукає цю властивість чи метод у його прототипі.
Існує кілька способів наслідування в JavaScript:

Прототипне наслідування:
- :white_check_mark: Кожен об'єкт має прототип, до якого можна звертатися для спадковості властивостей і методів.
- :white_check_mark: Можна створювати новий об'єкт на основі існуючого об'єкта і використовувати його властивості та методи.
- :white_check_mark: Зміни в прототипі впливають на всі об'єкти, які спадкують його властивості.

Класове наслідування (з ES6):
- :white_check_mark: Введення класів у JavaScript дозволяє використовувати синтаксис класів для створення об'єктів і наслідування.
- :white_check_mark: Класи можуть мати спеціальний метод constructor, який викликається при створенні нового об'єкта класу.
- :white_check_mark: За допомогою ключового слова extends можна створити новий клас, який успадковує властивості і методи з іншого класу.
- :white_check_mark: Виклик super() у конструкторі дочірнього класу викликає конструктор батьківського класу для ініціалізації спадкованих властивостей.

Приклад прототипного наслідування:
```
// Батьківський об'єкт
var Animal = {
  sound: '',
  makeSound: function() {
    console.log(this.sound);
  }
};

// Створення дочірнього об'єкту, який спадкує властивості від батьківського об'єкту
var Dog = Object.create(Animal);
Dog.sound = 'Woof!';

// Виклик методу makeSound в дочірньому об'єкті
Dog.makeSound(); // Виведе 'Woof!'
```

Приклад класового наслідування:
```
// Батьківський клас
class Animal {
  constructor(sound) {
    this.sound = sound;
  }

  makeSound() {
    console.log(this.sound);
  }
}

// Створення дочірнього класу, який успадковує властивості від батьківського класу
class Dog extends Animal {
  constructor() {
    super('Woof!');
  }
}

// Створення об'єкту дочірнього класу
var dog = new Dog();
dog.makeSound(); // Виведе 'Woof!'
```

</br>

2. :warning: **Яку функцію виконує Express.js?**
Express.js є легковаговим фреймворком для побудови веб-додатків на платформі Node.js. Він виконує функцію обробки маршрутів (routing) та створення сервера, який обробляє HTTP-запити і надсилає HTTP-відповіді.
Основні функції Express.js включають:
- :white_check_mark: Маршрутизація (Routing): Express.js надає простий та ефективний спосіб визначення маршрутів для обробки HTTP-запитів. За допомогою Express.js ви можете визначити шляхи (routes) для різних URL-адрес, HTTP-методів та типів запитів (GET, POST, PUT, DELETE тощо), і вказати функції-обробники (handler functions), які будуть виконуватися при отриманні відповідних запитів.
- :white_check_mark: Middleware: Express.js підтримує концепцію middleware - проміжних обробників, які можуть виконуватися перед або після обробки маршруту. Middleware може виконувати додаткові дії, такі як перевірка автентифікації, обробка запитів JSON, кешування, логування тощо. Ви можете використовувати готові middleware, або створювати свої власні.
- :white_check_mark: Обробка HTTP-запитів: Express.js дозволяє легко створювати обробники для різних типів HTTP-запитів. Ви можете встановлювати заголовки, отримувати параметри запиту, читати тіло запиту, відправляти HTTP-відповіді, встановлювати статус коди, робити перенаправлення та багато іншого.
- :white_check_mark: Шаблонізація (Template engines): Express.js може працювати з різними шаблонними двигунами, такими як EJS, Handlebars, Pug (Jade) тощо. Ви можете використовувати шаблонізацію для створення динамічного HTML-контенту, який буде відправлятися як відповідь на запити.
- :white_check_mark: Статичні файли: Express.js надає можливість встановлювати каталоги зі статичними файлами (наприклад, зображення, CSS, JavaScript), які будуть доступні напряму з сервера без необхідності обробки окремих запитів.
Express.js є популярним фреймворком завдяки своїй простоті, гнучкості та широким можливостям налаштування. Він підходить для розробки різноманітних веб-додатків, від невеликих API до повноцінних веб-додатків зі складною логікою.

</br>


3. :warning: **Що таке middleware? Наведіть приклади.**
Middleware в контексті веб-розробки є проміжним шаром програмного забезпечення, яке обробляє HTTP-запити та HTTP-відповіді між сервером і кінцевим додатком. Вони можуть виконувати певні дії перед обробкою запиту, після обробки запиту або обидві. Middleware може бути використано для реалізації функцій, таких як автентифікація, логування, обробка помилок, перенаправлення тощо.

Приклади middleware:
- :white_check_mark: Логування (Logging): Middleware для логування може виконувати реєстрацію подій, таких як отримання запиту, час виконання та відповідь сервера. Це може бути корисно для відстеження дій користувачів, виявлення проблем або аналізу роботи додатку.
- :white_check_mark: Автентифікація (Authentication): Middleware автентифікації перевіряє ідентифікацію користувача, часто на основі токенів, сесій або інших методів. Він може перевіряти правильність логіну та паролю, перевіряти дійсність токенів або перенаправляти на сторінку входу в разі невдалої автентифікації.
- :white_check_mark: Обробка помилок (Error Handling): Middleware для обробки помилок може перехоплювати виключення або помилки, які виникають під час обробки запиту, і надсилати адекватну відповідь з відповідним статусом коду. Він може також виконувати логування помилок для подальшого аналізу.
- :white_check_mark: Кешування (Caching): Middleware для кешування може зберігати результати попередньо оброблених запитів, щоб прискорити обробку подібних запитів у майбутньому. Він може перевіряти, чи є відповідь в кеші та повертати її без необхідності повторно обробляти запит.
- :white_check_mark: Локалізація (Localization): Middleware для локалізації дозволяє адаптувати контент до мови або регіону, вибраного користувачем. Він може перевіряти запити на наявність відповідних заголовків або параметрів, а потім змінювати контент додатку відповідно.
Це лише кілька прикладів middleware, існує багато інших можливостей для використання middleware для вирішення різних задач у вашому веб-додатку. Express.js, наприклад, має широкий спектр готових middleware, а також дає можливість створювати власні middleware для вашої специфічної логіки.

</br>


4. :warning: **Яка різниця між використанням шаблонізаторів для відображення і динамічними
сторінками на основі JavaScript?**

Різниця між використанням шаблонізаторів для відображення і динамічними сторінками на основі JavaScript полягає в тому, як сам процес відображення відбувається та коли відбувається обробка даних.

Шаблонізатори для відображення:
- :white_check_mark: Використовуються на серверній стороні (backend).
- :white_check_mark: Робота з шаблонами відбувається на сервері до того, як відповідь надсилається до клієнта.
- :white_check_mark: Шаблонізатори використовують певний синтаксис для вставки даних у шаблон, наприклад, використання плейсхолдерів або спеціальних тегів.
- :white_check_mark: Сервер генерує HTML-код з використанням шаблону та даних, і цей HTML-код надсилається клієнту для відображення.
- :white_check_mark: При зміні даних або переході на іншу сторінку, потрібно виконати повторний запит до сервера для отримання оновленої сторінки.

Динамічні сторінки на основі JavaScript:
- :white_check_mark: Використовуються на клієнтській стороні (frontend).
- :white_check_mark: Робота з динамічним контентом відбувається на стороні клієнта після завантаження HTML-сторінки.
- :white_check_mark: JavaScript використовується для маніпулювання DOM (Document Object Model) та зміни вмісту сторінки в реальному часі без потреби в повторних запитах до сервера.
- :white_check_mark: Дані можуть бути отримані з сервера через AJAX-запити або інші методи, і потім оброблені та відображені на сторінці без перезавантаження.
- :white_check_mark: Взаємодія зі сторінкою може бути більш інтерактивною, безперервною та швидкою завдяки використанню JavaScript.

Обидва підходи мають свої переваги та використовуються у різних сценаріях. Використання шаблонізаторів для відображення може бути зручним у випадках, коли вам потрібно генерувати статичний контент на сервері або коли ви працюєте зі складними шаблонами. Динамічні сторінки на основі JavaScript підходять для створення багатофункціональних та інтерактивних веб-додатків, які мають більш динамічний та живий характер.


</br>



5. :warning: **Як можна позбутися дублювання елементів сторінок використовуючи шаблонізатори, які повторюються - футер, хедер та інші?**
Щоб позбутися дублювання елементів сторінок, таких як футер, хедер та інші, використовуючи JavaScript, можна використовувати модульність та компонентний підхід:
- :white_check_mark: Створення окремих JavaScript файлів для кожного елемента: Реалізуйте кожен повторюваний елемент (футер, хедер і т.д.) у вигляді окремого JavaScript файлу, який містить код для створення або маніпуляції елементом. Потім включіть ці файли на відповідних сторінках, де ви хочете відображати ці елементи.
- :white_check_mark: Використання фреймворків або бібліотек для компонентної розробки: Використання фреймворків або бібліотек, таких як React, Vue.js або Angular, дозволяє розбити сторінку на компоненти. Кожен компонент може мати свій власний JavaScript код, який відповідає за відображення та функціональність компонента. Ви можете створити компоненти для футера, хедера та інших повторюваних елементів і використовувати їх на потрібних сторінках.
- :white_check_mark: Використання шаблонів розмітки (HTML templates): Використання шаблонів розмітки, таких як Handlebars, Mustache або Lodash, дозволяє вам описати структуру повторюваних елементів у вигляді шаблону. Ви можете використовувати ці шаблони, передавати дані та генерувати HTML-код на основі шаблону.
- :white_check_mark: Використання динамічного вставлення контенту: Використовуйте JavaScript для динамічного вставлення контенту у відповідні елементи сторінки. Наприклад, ви можете використовувати методи DOM для додавання або заміни елементів з певним вмістом.


</br>

lab 4

</br>

1. :warning: **Чому REST називається саме так?**
- :white_check_mark: REST (Representational State Transfer) отримав свою назву від Рой Філдінга, одного з основних авторів специфікації протоколу HTTP, у його дисертації "Архітектурні стилі та дизайн мережевих програм". REST став одним з основних архітектурних стилів для розробки веб-служб та веб-додатків.
- :white_check_mark: Назва "Representational State Transfer" відображає основну ідею цього підходу до взаємодії між клієнтом та сервером. REST використовує репрезентації ресурсів (Representations) та передачу їх стану (State Transfer) між клієнтом та сервером.
- :white_check_mark: У REST архітектурному стилі ресурси представлені як індивідуальні ідентифікатори (URL-адреси), до яких можна звернутися для отримання або зміни їх стану. Клієнти можуть взаємодіяти з цими ресурсами за допомогою стандартних операцій HTTP, таких як GET, POST, PUT і DELETE, що відповідають зчитуванню, створенню, оновленню та видаленню ресурсів відповідно.

</br>

2. :warning: **Опишіть поняття ідемпотентності в REST API.**
У REST API поняття ідемпотентності відноситься до властивості операцій, які можуть бути виконані повторно без створення додаткових змін у системі. Це означає, що незалежно від того, скільки разів викликана певна ідемпотентна операція, стан системи залишається незмінним після першого виклику.
Операції, які є ідемпотентними, можуть мати важливе значення у веб-сервісах, де надійність та стійкість даних є важливими факторами. Деякі ключові особливості ідемпотентних операцій в REST API включають:
- :white_check_mark: Повторюваність: Ідемпотентні операції можна виконувати повторно без негативних наслідків. Наприклад, повторне виконання операції GET на один і той самий ресурс поверне той самий результат без змін у системі.
- :white_check_mark: Запити без сторонніх ефектів: Ідемпотентні операції не вносять додаткових змін у систему при повторному виконанні. Наприклад, повторний POST-запит на створення ресурсу не створить новий ресурс, якщо він вже існує.
- :white_check_mark: Унікальність операцій: Ідемпотентні операції мають унікальну ідентифікацію, яка дозволяє серверу розпізнати повторні виклики. Це може бути досягнуто за допомогою унікальних ідентифікаторів запиту або за допомогою контролю стану ресурсу.
- :white_check_mark: Стабільність стану: Ідемпотентні операції забезпечують стабільність стану системи після повторних викликів. Незалежно від того, скільки разів виконується операція, стан системи залишається незмінним після першого виклику.

Ідемпотентність важлива в REST API, оскільки дозволяє забезпечити надійність, безпеку та стабільність взаємодії з сервером. Клієнти можуть повторно виконувати операції безперечності та боязні помилок чи неочікуваних змін у стані системи.

</br>

3. :warning: **Опишіть особливості (параметри, кешування, що передається в тілі) кожного з використаних в лабораторній методів HTTP.**
GET:
- :white_check_mark: Параметри: GET-запити передають параметри у URL-адресі в рядку запиту. Наприклад, GET /api/users?id=123.
- :white_check_mark: Кешування: GET-запити можуть бути кешовані. Якщо сервер отримує такий же GET-запит, він може повернути закешовані дані без звернення до джерела даних.
- :white_check_mark: Дані в тілі: GET-запити не передають дані в тілі запиту. Вони використовуються для отримання ресурсів або даних з сервера.

POST:
- :white_check_mark: Параметри: POST-запити передають параметри у тілі запиту, яке може бути в кодуванні URL або JSON форматі. Наприклад, POST /api/users з JSON-даними в тілі запиту.
- :white_check_mark: Кешування: POST-запити, за замовчуванням, не кешуються. Кожен POST-запит створює новий ресурс або змінює існуючий.
- :white_check_mark: Дані в тілі: POST-запити передають дані в тілі запиту. Це можуть бути дані форми або структуровані дані у JSON або іншому форматі.

PUT:
- :white_check_mark: Параметри: PUT-запити передають параметри у URL-адресі в рядку запиту, аналогічно до GET-запитів. Наприклад, PUT /api/users/123.
- :white_check_mark: Кешування: PUT-запити, за замовчуванням, не кешуються. Кожен PUT-запит змінює вказаний ресурс.
- :white_check_mark: Дані в тілі: PUT-запити передають дані в тілі запиту, як правило у JSON або іншому форматі. Ці дані використовуються для оновлення вказаного ресурсу.

Кожен метод HTTP має свою функціональність та призначення. GET використовується для отримання даних, POST - для створення нових ресурсів, а PUT - для оновлення існуючих ресурсів. Важливо враховувати правильне використання та відповідність методів HTTP залежно від сценарію взаємодії з сервером.

</br>


4. :warning: **Опишіть різницю методів PUT та POST в REST API.**
У REST API, методи PUT і POST використовуються для створення або оновлення ресурсів, але мають певні різниці в своєму функціоналі:

PUT (заміщення):

- :white_check_mark: Функціональність: Метод PUT використовується для створення або повного оновлення ресурсу замість його попереднього стану. Якщо ресурс вже існує, він замінюється на новий.
- :white_check_mark: URL: Запит PUT має вказувати конкретний URL ресурсу, до якого будуть застосовані зміни. Наприклад, /api/users/123.
- :white_check_mark: Ідемпотентність: Метод PUT є ідемпотентним, що означає, що повторні виклики не створюють додаткових змін у ресурсі. Оновлення ресурсу з однаковими даними залишає його стан незмінним.

POST (створення):

- :white_check_mark: Функціональність: Метод POST використовується для створення нового ресурсу або виконання дії, яка призводить до створення ресурсу. Кожен POST-запит може створювати новий ресурс незалежно від попереднього стану.
- :white_check_mark: URL: Запит POST зазвичай відправляє дані на загальний URL ресурсу або на спеціальний URL для виконання певної дії. Наприклад, /api/users для створення нового користувача.
- :white_check_mark: Ідемпотентність: Метод POST не є ідемпотентним. Кожен POST-запит призводить до створення нового ресурсу, тому повторні виклики можуть створювати дублікати ресурсів.

Отже, основна різниця між методами PUT і POST полягає в їх функціональності та наслідках на ресурси. PUT використовується для заміщення або повного оновлення ресурсу, тоді як POST використовується для створення нового ресурсу або виконання дії, яка призводить до створення ресурсу.

</br>



5. :warning: **На які дії доречно використовувати кешування.**

Кешування є корисною технікою для покращення продуктивності та зниження навантаження на сервери. Використовуючи кешування, можна зберігати копії ресурсів або результати обчислень і повторно їх використовувати без необхідності повторних обробок. Основні дії, для яких доречно використовувати кешування, включають:
- :white_check_mark: Часті запити до статичних або малозмінних даних: Якщо деякі дані рідко змінюються, але часто запитуються, можна зберігати їх у кеші. Це може бути, наприклад, статичні сторінки, зображення, CSS-файли, які рідко змінюються.
- :white_check_mark: Результати обчислень або складних операцій: Якщо на сервері виконується складний обрахунок або операція, результат можна закешувати, щоб уникнути повторних обчислень при наступних запитах з ідентичними параметрами.
- :white_check_mark: Запити до зовнішніх ресурсів: Кешування може бути використане для збереження результатів запитів до зовнішніх ресурсів, таких як API сторонніх служб. Це дозволяє уникнути надмірного навантаження на зовнішні ресурси та забезпечує швидку відповідь для повторних запитів.
- :white_check_mark: Великі обсяги даних: Кешування може бути корисним для збереження великих обсягів даних, таких як списки користувачів, продуктів або новин. Замість виконання запитів до бази даних за кожним запитом, дані можуть бути закешовані та повторно використані.
Враховуйте, що не всі типи даних або операцій є підходящими для кешування. Наприклад, дані, що швидко змінюються, чутливі до конфіденційності або потребують завжди актуальної інформації, можуть не підходити для кешування. Кешування потребує уважного аналізу та врахування конкретних вимог вашого додатку чи системи.
</br>

6. :warning: **Опишіть як в REST API виглядає адреса для пошуку в списку обʼктів однієї з сутностей. Наприклад, всі предмети, які вивчаються учнем.**
У REST API адреса для пошуку в списку об'єктів однієї з сутностей може використовувати параметри запиту для вказання критеріїв пошуку. У вашому прикладі, якщо ви шукаєте всі предмети, які вивчає учень, адреса може виглядати так:
`GET /api/students/{studentId}/subjects`
У цій адресі: 
- :white_check_mark: `/api/students` - це шлях до ресурсу "students", який представляє учнів.
- :white_check_mark: `{studentId}` - це параметр запиту, який вказує ідентифікатор конкретного учня.
- :white_check_mark: `/subjects` - це підшлях, який вказує на список предметів, пов'язаних з учнем.

Таким чином, запит GET `/api/students/123/subjects` буде шукати список предметів, які вивчає учень з ідентифікатором 123.
Сама структура адреси може варіюватися в залежності від конкретного дизайну вашого REST API та прийнятих у вас конвенцій.

</br>


5 lab

</br>

1. :warning: **Опишіть різницю між реляційними та документо-орієнтованими базами даних.**


- :white_check_mark: Структура даних: Реляційні бази даних використовують таблиці зі структурованими реляціями, де дані організовані у вигляді стовпців і рядків. Кожна таблиця має фіксовану кількість стовпців з визначеними типами даних. У документо-орієнтованих базах даних дані зберігаються у вигляді документів, які можуть бути вкладеними або містити структуру з ключами і значеннями. Документи можуть бути гнучкими і містити різні поля без фіксованої структури.
- :white_check_mark: Схема даних: Реляційні бази даних потребують заданої схеми заздалегідь, яка визначає структуру таблиць, типи даних та зв'язки між ними. Зміна схеми може бути складною операцією. У документо-орієнтованих базах даних немає жорсткої схеми. Кожен документ може мати власну структуру без потреби в попередньому визначенні схеми. Це робить їх більш гнучкими та легшими для масштабування.
- :white_check_mark: Запити та мови запитів: Реляційні бази даних використовують мову структурованих запитів SQL (Structured Query Language) для створення, оновлення та отримання даних. Запити базуються на реляціях між таблицями. У документо-орієнтованих базах даних для запитів використовуються спеціалізовані мови запитів, такі як MongoDB Query Language (MQL) або JavaScript-подібні запити. Запити дозволяють отримувати документи за певними умовами та виконувати різноманітні операції.

</br>

2. :warning: **Опишіть поняття транзакцій. Чи є вони в реляційних та документо-орієнтованих
базах даних?**

- :white_check_mark: Транзакція - це логічна одиниця роботи з базою даних, яка складається з однієї або кількох операцій бази даних, які повинні бути виконані як атомарна, консистентна, ізольована та стійка (ACID властивості). Транзакції забезпечують цілісність даних та впевненість у тому, що база даних перебуває в правильному стані навіть у випадку збоїв або конкуренції.
- :white_check_mark: У реляційних базах даних транзакції є вбудованим інструментом і підтримуються стандартом SQL. Транзакційні операції, такі як COMMIT (застосувати зміни) і ROLLBACK (скасувати зміни), дозволяють групувати кілька запитів разом і забезпечувати атомарність та консистентність даних.
- :white_check_mark: У документо-орієнтованих базах даних підтримка транзакцій може варіюватися залежно від конкретної системи управління базами даних (СУБД). Деякі документо-орієнтовані бази даних, наприклад MongoDB, надають підтримку транзакцій за допомогою операцій пошуку та модифікації даних, а також операцій з блокуванням. Інші СУБД можуть пропонувати інші механізми для забезпечення цілісності даних та атомарності, такі як оптимістичні блокування чи механізми версіонування.
- :white_check_mark: Загалом, реляційні бази даних мають ширшу підтримку для транзакцій, включаючи ACID-властивості, порівняно з документо-орієнтованими базами даних, де рівень підтримки транзакцій може залежати від конкретної реалізації СУБД.

</br>

3. :warning: **Які є способи реалізувати ManyToMany звʼязок в базах даних?**

- :white_check_mark: Таблиця зв'язку з унікальними ідентифікаторами: Створюється третя таблиця, яка містить унікальні ідентифікатори об'єктів, пов'язаних зі зв'язком "багато до багатьох". Ця таблиця містить стовпці, які вказують на ідентифікатори об'єктів з обох боків зв'язку. Наприклад, якщо ми маємо таблиці "Студенти" і "Курси", то створюється третя таблиця "Студенти_Курси", яка містить стовпці "Студент_ID" і "Курс_ID". Кожний рядок у таблиці "Студенти_Курси" представляє зв'язок між певним студентом і певним курсом.
- :white_check_mark: Стовпець з масивом або списком: В деяких системах баз даних можна мати стовпець у таблиці, який містить масив або список значень. У цьому випадку, у стовпці зберігається список ідентифікаторів об'єктів, пов'язаних зі зв'язком "багато до багатьох". Наприклад, у таблиці "Курси" може бути стовпець "Студенти", що містить масив або список ідентифікаторів студентів, які беруть участь у цьому курсі.
- :white_check_mark: Використання комбінації зовнішніх ключів: В цьому підході кожна з таблиць має зовнішній ключ, який посилається на примірник іншої таблиці. Наприклад, у таблиці "Студенти" може бути стовпець "Курс_ID", який посилається на ідентифікатор курсу, в якому бере участь студент. У таблиці "Курси" також може бути стовпець "Студент_ID", який посилається на ідентифікатор студента. Це дозволяє встановити зв'язок "багато до багатьох" між об'єктами.
- :white_check_mark: ORM-інструменти: Об'єктно-реляційні картографи (ORM) надають спеціальні засоби для роботи зі зв'язком "багато до багатьох". Вони можуть автоматично створювати проміжну таблицю зв'язку або використовувати інші способи мапування цього типу зв'язку на рівні об'єктів.

</br>

4. :warning: **Опишіть особливості БД Redis. Чому вона швидка? Де її краще використовувати?**

- :white_check_mark:  Ін-пам'ять: Redis зберігає дані у пам'яті, що дозволяє йому забезпечувати швидкий доступ до даних. Частіше використовувані дані зберігаються у пам'яті, що дозволяє досягти низької латентності і великої продуктивності.
- :white_check_mark:  Простота структури даних: Redis використовує простий ключ-значення підхід, де кожен ключ пов'язаний з певним значенням. Це спрощує операції зчитування та запису даних та забезпечує швидкий доступ до них.
- :white_check_mark:  Підтримка різних типів даних: Redis підтримує різні типи даних, такі як рядки, хеші, списки, набори і послідовності, що робить його гнучким і придатним для різних використань.
- :white_check_mark:  Кешування та зберігання даних: Redis може використовуватися як кеш для швидкого доступу до популярних даних або як постійне сховище даних. Він також надає можливості для зберігання та реплікації даних, що забезпечує стійкість та надійність.
Redis є інструментом з високою продуктивністю, тому він найкраще підходить для сценаріїв, де потрібно швидко доступатися до даних. Деякі типові використання Redis включають:
- :white_check_mark:  Кешування: Redis часто використовується як кеш для зберігання часто використовуваних даних, таких як результати запитів до бази даних або обчислення.
- :white_check_mark:  Сесії та сеанси: Redis може зберігати стан сесій користувачів або сеансів веб-додатків, дозволяючи швидкий доступ до даних та масштабованість.
- :white_check_mark:  Реальний час: Завдяки низькій латентності та швидким операціям, Redis підходить для реалізації реального часу додатків, таких як чати або системи черг.
- :white_check_mark:  Розподілені системи: Redis надає можливості реплікації та шардування, що дозволяє побудувати розподілені системи з високою доступністю та швидким доступом до даних.
Проте, слід враховувати, що Redis має обмежений розмір доступної оперативної пам'яті і не є найкращим вибором для зберігання великих обсягів даних. Також варто враховувати, що Redis не має вбудованої підтримки для складних запитів та операцій, які можуть здійснюватися в реляційних базах даних.



